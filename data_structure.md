## 1. 数组(Array)

#### 1.1 定义

数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。



#### 1.2 特征

* 数组是线性表，只有前后两个方向，所以数组的插入和删除操作比较低效，但是可以在任何位置插入和删除元素
* 连续的内存空间和形同类型的数据
* 最大的优点是可以随机访问，通过下标随机访问的时间复杂度为O(1)，所以，数组适合查找操作



#### 1.3 js中数组方法的时间复杂度

* Insert / remove from end - O(1)
* Insert / remove from beginning - O(n)
* Access - O(1)
* Search - O(n)
* Push / Pop - O(1)
* Shift  / unshift / concat / slice /splice - O(n)
* forEach / map / filter /reduce - O(n)





## 2. 栈结构(Stack)

#### 2.1 定义

一种受限的线性存储结构，FILO



#### 2.2 特征

* LIFO，先进后出
* 限定只能在一端进行插入和删除操作(分为进栈和出栈)



#### 2.3 应用场景

* 函数调用栈：特别是函数之间相互调用存在依赖关系时，如A调用B，B中调用了C，C中又调用了D。就是先执行A，然后将B压入栈，再把C压入栈，最后D压入栈。然后开始依次执行并弹出栈。所以递归容易出现栈溢出的问题

#### 2.4 常见操作

- push()
- pop()
- peek()
- size()
- isEmpty()
- toString()



## 3. 队列(Queue)

#### 3.1 定义

受限的线性表，FIFO



#### 3.2 特征

- 只允许在表的前端进行删除操作，在后端进行插入操作

#### 3.3 常见操作

- enqueue()：向队列尾部添加项
- dequeue()：移除队列最前面的项，并返回出去
- front()：返回队列中最前面的一项，但是不做任何操作
- isEmpty()
- size()
- toString()



#### 3.4 优先级队列[^注释]

[^注释]: 队列按优先级排序，接收参数1为元素，参数2为优先级

应用场景 —— 插队





## 4. 链表(Linked List)

#### 4.1 定义

用链接方式存储一系列元素的线性表



#### 4.2 特征

- 链表中的元素在内存中**不必是连续的空间**，所以可以充分利用计算机的内存，实现灵活的内存动态管理
- 链表的每个元素由一个存储**元素本身的节点**和一个**指向下一个元素的引用**组成
- 链表不必在创建时就确定大小，并且大小可以无限的延伸下去
- 链表在**插入和删除**数据时，时间复杂度可以达到O(1)，相对数组**效率高很多**
- 但是也有缺点，比如链表访问元素时，任何一个位置的元素都需要从头开始访问，直到找到对应的元素，无法跳过第一个元素访问任何一个元素
- 单向链表只能从头遍历到尾或者从尾遍历到头。链表相连的过程是单向的
- 对于单向链表来说，到达下一个节点是轻松的，但是回到上一个节点是很麻烦的



![image-20221130164134585](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221130164134585.png)





#### 4.3 常见操作

- append(ele)：向列表尾部添加一个新的项
- insert(position, ele)：向列表特定位置插入一个新的项
- get(position):获取对应位置的元素
- indexOf(ele)：返回该元素在列表中的索引值，没有则返回-1
- update(position,data)：修改某个位置的元素
- removeAt(position)：移除列表中特定一项
- remove(ele)：从列表中移除一项
- isEmpty()
- size()
- toString()





## 5. 双向链表(Doubly Linked List)

#### 5.1 描述

- 既可以从头遍历到尾，也可以从尾遍历到头
- 链表相连的过程是双向的
- 一个节点既有向前连接的引用，也有一个向后连接的引用
- 缺点是每次在插入或删除某个节点的时候，需要处理四个引用，而不是两个；并且相对于单向链表，占用的内存空间更大一些

#### 5.2 特征

- 可以使用一个head和一个tail分别指向头部和尾部的节点
- 每个节点由三部分组成：前一个节点的指针(prev)+item+后一个节点的指针(next)
- 第一个节点的prev为null，最后一个节点的next为null



![image-20221201170923206](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221201170923206.png)



#### 5.3 常见操作

- append(ele)：向列表尾部添加一个新的项
- insert(position, ele)：特定位置插入新的项
- get(position)：获取对应位置的元素
- indexOf(ele)：返回元素索引，如没有该元素则返回-1
- update(position, ele)：修改指定位置的元素
- removeAt(position)：从列表特定位置移除一项
- remove(ele)：从列表移除一项
- isEmpty()
- size()
- toString()
- forwardString()：返回正向遍历的节点字符串形式
- backwardString()：返回反向遍历的节点字符串形式

​	





## 6. 集合结构(Set)

#### 6.1 定义

一组无序的，不能重复的元素。常见的实现方式是哈希表



#### 6.2 特征

- 没有顺序，也不能重复
- 不能通过下标值进行访问，相同的对象在集合中只会存在一份



#### 6.3

- add(value)
- remove(value)
- has(value)
- clear()
- size()
- values()



#### 6.4 集合间操作

- 并集
- 交集
- 差集
- 子集

![image-20221203145821814](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221203145821814.png)







## 7. 字典(Dictionary)

#### 7.1 定义

与集合类似，字典也是用来存储唯一值的数据结构，以键值对的形式来存储数据



#### 7.2 特征

- 一一对应的映射关系
- 使用字典的方式，可以通过key取出value
- 字典中的key是不可以重复的，而value可以重复，并且字典中的key是无序的



#### 7.3 常见操作

- set(key, value)：向字典中添加新元素
- remove(key)：通过使用键值来从字典中移除键值对应的数据值
- has(key)
- get(key)
- clear()
- size()
- keys()
- values()







## 8. 哈希表(Hash Table)

#### 8.1 定义

也叫做散列表。是根据关键字和值直接进行访问的数据结构





#### 8.2 特征

- 通常基于数组进行实现的
- 可以非常快速的执行插入-删除-查找操作，且时间复杂度接近O(1)
- 但是哈希表中的数据是无序的，所以不能以一种固定的方式来遍历元素
- 且哈希表中的key是不允许重复的，不能放置相同你的key



#### 8.3 哈希表原理

哈希表的做法其实就是将key值转换成下标值，再把对应value存储在该下标对应的数组空间里，要做到这点，就需要对key值进行转化，将key通过一个固定的算法转换成数组下标的函数就叫做***哈希函数***。



#### 8.4 哈希冲突

哈希函数将key值转换成一个整型数字(哈希化:相加法或幂相乘法)，然后再将该数字对数组长度进行取余(压缩整数)，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。这时，因为取余的结果在0~9之间，所以很容易出现重复的情况。

这种在通过哈希函数将key转换为下标值的时出现的转换下标值相同的问题，这就称作***哈希冲突***，解决哈希冲突有几种办法，下面记录两种常见方案。

- 链地址法
- 开放地址法



##### 8.4.1 处理哈希冲突之——链地址法



![image-20221205184818833](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205184818833.png)



链地址法就是使每个数组单元中存储的不再是单个数据，而是一个**链条**。由数组或者链表组成的有指向的数据结构，一旦发现重复，就将重复的元素插入到该下标值对应链表的首端或者末端。当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询数据即可。



##### 8.4.2 处理哈希冲突之——开放地址法 



![image-20221205185859017](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205185859017.png)



开放地址法就是在出现冲突时去寻找数组中空白的单元格来添加重复的数据。其中，寻找位置又有三种方法：



`线性探测`

操作：

- 插入：线性查找空白的单元格，即直接从index+1的位置开始一点一点查找空的位置放置冲突元素
- 查询：如果通过该方法插入冲突元素的话，相对应的，查询该元素就是将该元素和转换后的下标值的对应元素对比，如果不一致，就index+1往后找，直到找到与该元素一致的，期间如果查询到空位置，也会停止，因为其后有空位置则代表没有该下标冲突元素(如果有的话会被添加到该空白位置)。拿32举例子的话，上图对应的应查询下标值为2的元素，为82，与key值32不一致，则index+1往后查询，下一个为空位置，则停止查询，说明没有32这个元素
- 删除：删除元素时，不能直接将该下标位置内容置为null，因为会影响到查询(线性探测去查询冲突元素时碰到空白位置会停止)，所以通常会将它进行特殊化处理(比如设为-1).当看到-1时，就知道查询时应继续往后查询，但是插入时该下标位置是可以放置数据的



问题：

- 如果在没有任何数据的时候，插入22-23-24-25-26，那么意味着下标值2-3-4-5-6的位置都有元素，这种形成的一连串填充单元就叫做**聚集**
- 聚集会影响哈希表的性能。比如插入32时，会发现后面连续的单元都不允许放置数据，则需要探测很长的距离







`二次探测：`



![image-20221205193033456](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205193033456.png)





`再哈希法：`

![image-20221205193309069](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205193309069.png)





##### 8.4.3 哈希化效率

哈希表效率与冲突解决有关，而解决冲突又与填装因子有关。

填装因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值。即：

`装填因子 = 总数据项 / 哈希表长度`

开放地址法的装填因子最大是1，因为冲突元素要寻找空白单元放置，而链地址法的装填因子可以大于1，因为链地址可以无限延伸下去

在真实开发中，使用**链地址法**的**情况较多**(比如Java中的HashMap)





#### 8.5 哈希函数

哈希表主要优点是它的速度。而让哈希函数中<u>尽量少的有乘法和除法</u>是提高速度的办法之一，因为它们的性能是比较低的。设计好的哈希函数应该包括以下优点：

- 快速的计算
- 均匀的分布

![image-20221205225357402](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225357402.png)



 ![image-20221205225905293](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225905293.png)



![image-20221205225914817](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225914817.png)



![image-20221205230243333](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205230243333.png)



![image-20221205230527163](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205230527163.png)





#### 8.6 常见操作

- 插入&修改
- 获取
- 删除





#### 8.7 哈希扩容

##### 8.7.1 为什么需要扩容？

因为随着数据量增多，每一个index对应的bucket会越来越长，每次查询key时遍历的数据也会越来越多，就会造成效率的降低。所以在合适的情况对数组进行扩容，比如扩容两倍。

同样的，在扩容之后，如果删除了很多元素导致元素很少，但是数组容量很大的情况下，也需要对数组做减小容量的操作。



`(ps: 扩容后/缩小容量后的bucket长度最好也是质数，有利于元素转换后的index值在数组中均匀分布，减少元素连串聚集的问题)`



##### 8.7.2 如何进行扩容/减小容量

在 loadFactor > 0.75 时进行增大两倍容量的操作

在 loadFactor < 0.25 时进行减小两倍容量的操作





​    



## 9. 树(Tree)

#### 9.1 定义

由 `n`（`n>0`）个有限节点组成一个具有层次关系的集合，看起来像根朝上，叶朝下的树



#### 9.2 树的术语

- 根(Root)
- 子树(SubTree)
- 节点的度(Degree)：节点的子树个数
- 树的度：树的所有节点中最大的度数
- 叶节点(Leaf)：度为0的节点
- 父节点(Parent)
- 子节点(Chlid)
- 兄弟节点(Sibling)
- 路径和路径长度：从节点n1到nk的路径为一个节点序列n1,n2,n3,...,nk。路径长度是指路径所包含边的个数
- 节点层次(Level)：根节点在1层，其他任一节点的层数是其父子节点的层数+1
- 树的深度(Depth)：树中所有节点中最大层次是这棵树的深度



#### 9.3 二叉树(Binary Tree)

##### 9.3.1 定义

树中每个节点最多只有两个节点的树就是二叉树。二叉树可以为空，也就是没有节点；若不为空，则它是由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成，下图为它的五种形态：



![image-20221207182023531](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207182023531.png)





##### 9.3.2 特征

- 一个二叉树的第i层的最大节点数为：2^(i-1)^, i >= 1
- 深度为k的二叉树有最大节点总数为：2^k-1^,k>= 1
- 对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足关系 n0 = n2 + 1；解释如下图

![image-20221207184923872](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207184923872.png)







##### 9.3.3 完美二叉树

完美二叉树(Perfect Binary Tree)，也称为满二叉树(Full Binary Tree)，指除了最下一层的叶节点外，每层节点都有2个子节点的二叉树，如图：

![image-20221207185340029](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207185340029.png)





##### 9.3.4 完全二叉树

完全二叉树(Complete Binary Tree) 满足以下条件

- 除二叉树最后一层外，其他各层的节点数都达到最大个数
- 且最后一层从左向右的叶节点连续存在，只缺右侧若干节点

![image-20221207185802510](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207185802510.png)



```
这里就不是完全二叉树，因为它最后一层的左侧叶节点有缺失
```



ps: 完美二叉树是特殊的完全二叉树





##### 9.3.5 二叉树的存储

二叉树的存储常见的方式为数组和链表。

完全二叉树一般用数组，非完全二叉树一般使用链表，所以链表用的多一些

![image-20221207192955198](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207192955198.png)



![image-20221207193010323](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221207193010323.png)



##### 9.3.6 二叉搜索树

二叉搜索树(BST, Binary Search Tree)，也称为二叉排序树或二叉查找树。满足以下性质：

- 二叉搜索树是一颗二叉树，可以为空
- 非空左子树的所有键值小于其根节点的键值
- 非空右子树的所有键值大于其根节点的键值
- 左、右子树本身也都是二叉搜索树

 

所以二叉搜索树相对较小的值总是保存在左节点上，相对较大的值总是保存在右节点上



##### 9.3.7 二叉搜索树的特征

- 可以快速找到给定关键字的数据项(速度取决于二叉树的深度)，并且可以快速插入和删除数据

- 因为二叉树的操作速度取决于二叉树的深度，所以当二叉树插入的数据连续偏小或连续偏大时，会使二叉树两边子树的不平衡，从而导致二叉树深度变大，这也是二叉搜索树的一个*缺陷*。此种二叉树称为非平衡二叉树
- **非平衡二叉树**查找和插入等操作效率是**O(N)**
- **平衡二叉树**的搜索数据应该是左右分布均匀的，所以插入和查找等操作的效率是**O(logN)**



##### 9.3.8 二叉搜索树常见操作

- insert(key)
- search(key)
- inOrderTraverse：中序遍历
- preOrderTraverse：前序遍历
- postOrderTraverse：后序遍历
- min：返回树中最小的值/键
- max：返回树中最大的值/键
- remove(key)





#### 9.4 树的平衡性

为了能以较快的时间O(logN)来操作一棵树，我们需要保证树大部分是平衡的，也就是说树中每个节点左边的子孙节点的个数，应该尽可能的等于右边的子孙节点的个数。实现方法有AVL树和红黑树，在实际中使用的一般都是红黑树。



#### 9.5 红黑树

##### 9.5.1 定义

红黑树是一种自平衡二叉查找树，是一种特化的AVL树，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而较高的查找性能。



##### 9.5.2 特征

- 节点是红色或黑色
- 根节点是黑色
- 每个叶子节点都是黑色的空节点(NIL节点)
- 每个红色节点的两个子节点都是黑色(从每个叶子节点到根的所有路径上不能有两个连续的红色节点)
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
- 从根到叶子的最长可能路径，不会超过最短可能路径的两倍长



![image-20221212182318601](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221212182318601.png)



##### 9.5.3 变换

- 变色

![image-20221212182425436](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221212182425436.png)



- 左旋转

![image-20221212183016058](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221212183016058.png)





- 右旋转

![image-20221212182821435](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221212182821435.png)





##### 9.5.4 常见操作

- 插入操作(下面将插入节点称为N，插入节点的父节点称为P，插入节点父节点的父节点称为G，插入节点父节点的兄弟节点称为U)


| 情况                             | 操作方案                                                     |
| -------------------------------- | ------------------------------------------------------------ |
| 新节点N位于树的根上，没有父节点  | 直接插入新节点，将新节点颜色变为黑色                         |
| 新节点的父节点P是黑色            | 直接插入新节点，并补齐NIL节点                                |
| 新节点的父节点P和叔节点U都是红色 | 对调祖节点G和父叔节点的颜色，祖变为红，父叔变为黑            |
| 父红叔黑，且新节点为左子节点     | 先变色，祖G变为红色，父P变为黑色，再以祖G节点为准作右旋转    |
| 父红叔黑，且新节点为右子节点     | - 以父P为准做左旋转<br />- 再将P及子树作为新节点插入<br />- 变为了父红叔黑且为左子节点的情况，再根据这种情况的操作方案，先变色，后旋转(结合图示)<br /> |

![image-20221224114340312](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221224114340312.png)

![image-20221224114428695](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221224114428695.png)

![image-20221224114452234](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221224114452234.png)

![image-20221224114506995](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221224114506995.png)



























## # 各个结构的优缺点对比以及适用场景