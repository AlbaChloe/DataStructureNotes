## 1. 数组

#### 1.1 定义

数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。



#### 1.2 特征

* 数组是线性表，只有前后两个方向，所以数组的插入和删除操作比较低效，但是可以在任何位置插入和删除元素
* 连续的内存空间和形同类型的数据
* 最大的优点是可以随机访问，通过下标随机访问的时间复杂度为O(1)，所以，数组适合查找操作



#### 1.3 js中数组方法的时间复杂度

* Insert / remove from end - O(1)
* Insert / remove from beginning - O(n)
* Access - O(1)
* Search - O(n)
* Push / Pop - O(1)
* Shift  / unshift / concat / slice /splice - O(n)
* forEach / map / filter /reduce - O(n)





## 2. 栈结构

#### 2.1 定义

一种受限的线性存储结构，FILO



#### 2.2 特征

* LIFO，先进后出
* 限定只能在一端进行插入和删除操作(分为进栈和出栈)



#### 2.3 应用场景

* 函数调用栈：特别是函数之间相互调用存在依赖关系时，如A调用B，B中调用了C，C中又调用了D。就是先执行A，然后将B压入栈，再把C压入栈，最后D压入栈。然后开始依次执行并弹出栈。所以递归容易出现栈溢出的问题

#### 2.4 常见操作

- push()
- pop()
- peek()
- size()
- isEmpty()
- toString()



## 3. 队列

#### 3.1 定义

受限的线性表，FIFO



#### 3.2 特征

- 只允许在表的前端进行删除操作，在后端进行插入操作

#### 3.3 常见操作

- enqueue()：向队列尾部添加项
- dequeue()：移除队列最前面的项，并返回出去
- front()：返回队列中最前面的一项，但是不做任何操作
- isEmpty()
- size()
- toString()



#### 3.4 优先级队列[^注释]

[^注释]: 队列按优先级排序，接收参数1为元素，参数2为优先级

应用场景 —— 插队





## 4. 链表

#### 4.1 定义

用链接方式存储一系列元素的线性表



#### 4.2 特征

- 链表中的元素在内存中**不必是连续的空间**，所以可以充分利用计算机的内存，实现灵活的内存动态管理
- 链表的每个元素由一个存储**元素本身的节点**和一个**指向下一个元素的引用**组成
- 链表不必在创建时就确定大小，并且大小可以无限的延伸下去
- 链表在**插入和删除**数据时，时间复杂度可以达到O(1)，相对数组**效率高很多**
- 但是也有缺点，比如链表访问元素时，任何一个位置的元素都需要从头开始访问，直到找到对应的元素，无法跳过第一个元素访问任何一个元素
- 单向链表只能从头遍历到尾或者从尾遍历到头。链表相连的过程是单向的
- 对于单向链表来说，到达下一个节点是轻松的，但是回到上一个节点是很麻烦的



![image-20221130164134585](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221130164134585.png)





#### 4.3 常见操作

- append(ele)：向列表尾部添加一个新的项
- insert(position, ele)：向列表特定位置插入一个新的项
- get(position):获取对应位置的元素
- indexOf(ele)：返回该元素在列表中的索引值，没有则返回-1
- update(position,data)：修改某个位置的元素
- removeAt(position)：移除列表中特定一项
- remove(ele)：从列表中移除一项
- isEmpty()
- size()
- toString()





## 5. 双向链表

#### 5.1 描述

- 既可以从头遍历到尾，也可以从尾遍历到头
- 链表相连的过程是双向的
- 一个节点既有向前连接的引用，也有一个向后连接的引用
- 缺点是每次在插入或删除某个节点的时候，需要处理四个引用，而不是两个；并且相对于单向链表，占用的内存空间更大一些

#### 5.2 特征

- 可以使用一个head和一个tail分别指向头部和尾部的节点
- 每个节点由三部分组成：前一个节点的指针(prev)+item+后一个节点的指针(next)
- 第一个节点的prev为null，最后一个节点的next为null



![image-20221201170923206](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221201170923206.png)



#### 5.3 常见操作

- append(ele)：向列表尾部添加一个新的项
- insert(position, ele)：特定位置插入新的项
- get(position)：获取对应位置的元素
- indexOf(ele)：返回元素索引，如没有该元素则返回-1
- update(position, ele)：修改指定位置的元素
- removeAt(position)：从列表特定位置移除一项
- remove(ele)：从列表移除一项
- isEmpty()
- size()
- toString()
- forwardString()：返回正向遍历的节点字符串形式
- backwardString()：返回反向遍历的节点字符串形式

​	





## 6. 集合结构

#### 6.1 定义

一组无序的，不能重复的元素。常见的实现方式是哈希表



#### 6.2 特征

- 没有顺序，也不能重复
- 不能通过下标值进行访问，相同的对象在集合中只会存在一份



#### 6.3

- add(value)
- remove(value)
- has(value)
- clear()
- size()
- values()



#### 6.4 集合间操作

- 并集
- 交集
- 差集
- 子集

![image-20221203145821814](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221203145821814.png)







## 7. 字典

#### 7.1 定义

与集合类似，字典也是用来存储唯一值的数据结构，以键值对的形式来存储数据



#### 7.2 特征

- 一一对应的映射关系
- 使用字典的方式，可以通过key取出value
- 字典中的key是不可以重复的，而value可以重复，并且字典中的key是无序的



#### 7.3 常见操作

- set(key, value)：向字典中添加新元素
- remove(key)：通过使用键值来从字典中移除键值对应的数据值
- has(key)
- get(key)
- clear()
- size()
- keys()
- values()







## 8. 哈希表

#### 8.1 定义

也叫做散列表。是根据关键字和值直接进行访问的数据结构





#### 8.2 特征

- 通常基于数组进行实现的
- 可以非常快速的执行插入-删除-查找操作，且时间复杂度接近O(1)
- 但是哈希表中的数据是无序的，所以不能以一种固定的方式来遍历元素
- 且哈希表中的key是不允许重复的，不能放置相同你的key



#### 8.3 哈希表原理

哈希表的做法其实就是将key值转换成下标值，再把对应value存储在该下标对应的数组空间里，要做到这点，就需要对key值进行转化，将key通过一个固定的算法转换成数组下标的函数就叫做***哈希函数***。



#### 8.4 哈希冲突

哈希函数将key值转换成一个整型数字(哈希化:相加法或幂相乘法)，然后再将该数字对数组长度进行取余(压缩整数)，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。这时，因为取余的结果在0~9之间，所以很容易出现重复的情况。

这种在通过哈希函数将key转换为下标值的时出现的转换下标值相同的问题，这就称作***哈希冲突***，解决哈希冲突有几种办法，下面记录两种常见方案。

- 链地址法
- 开放地址法



##### 8.4.1 处理哈希冲突之——链地址法



![image-20221205184818833](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205184818833.png)



链地址法就是使每个数组单元中存储的不再是单个数据，而是一个**链条**。由数组或者链表组成的有指向的数据结构，一旦发现重复，就将重复的元素插入到该下标值对应链表的首端或者末端。当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询数据即可。



##### 8.4.2 处理哈希冲突之——开放地址法 



![image-20221205185859017](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205185859017.png)



开放地址法就是在出现冲突时去寻找数组中空白的单元格来添加重复的数据。其中，寻找位置又有三种方法：



`线性探测`

操作：

- 插入：线性查找空白的单元格，即直接从index+1的位置开始一点一点查找空的位置放置冲突元素
- 查询：如果通过该方法插入冲突元素的话，相对应的，查询该元素就是将该元素和转换后的下标值的对应元素对比，如果不一致，就index+1往后找，直到找到与该元素一致的，期间如果查询到空位置，也会停止，因为其后有空位置则代表没有该下标冲突元素(如果有的话会被添加到该空白位置)。拿32举例子的话，上图对应的应查询下标值为2的元素，为82，与key值32不一致，则index+1往后查询，下一个为空位置，则停止查询，说明没有32这个元素
- 删除：删除元素时，不能直接将该下标位置内容置为null，因为会影响到查询(线性探测去查询冲突元素时碰到空白位置会停止)，所以通常会将它进行特殊化处理(比如设为-1).当看到-1时，就知道查询时应继续往后查询，但是插入时该下标位置是可以放置数据的



问题：

- 如果在没有任何数据的时候，插入22-23-24-25-26，那么意味着下标值2-3-4-5-6的位置都有元素，这种形成的一连串填充单元就叫做**聚集**
- 聚集会影响哈希表的性能。比如插入32时，会发现后面连续的单元都不允许放置数据，则需要探测很长的距离







`二次探测：`



![image-20221205193033456](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205193033456.png)





`再哈希法：`

![image-20221205193309069](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205193309069.png)





##### 8.4.3 哈希化效率

哈希表效率与冲突解决有关，而解决冲突又与填装因子有关。

填装因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值。即：

`装填因子 = 总数据项 / 哈希表长度`

开放地址法的装填因子最大是1，因为冲突元素要寻找空白单元放置，而链地址法的装填因子可以大于1，因为链地址可以无限延伸下去

在真实开发中，使用**链地址法**的**情况较多**(比如Java中的HashMap)





#### 8.5 哈希函数

哈希表主要优点是它的速度。而让哈希函数中<u>尽量少的有乘法和除法</u>是提高速度的办法之一，因为它们的性能是比较低的。设计好的哈希函数应该包括以下优点：

- 快速的计算
- 均匀的分布

![image-20221205225357402](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225357402.png)



 ![image-20221205225905293](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225905293.png)



![image-20221205225914817](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205225914817.png)



![image-20221205230243333](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205230243333.png)



![image-20221205230527163](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20221205230527163.png)





#### 8.6 常见操作

- 插入&修改
- 获取
- 删除





#### 8.7 哈希扩容

##### 8.7.1 为什么需要扩容？

因为随着数据量增多，每一个index对应的bucket会越来越长，每次查询key时遍历的数据也会越来越多，就会造成效率的降低。所以在合适的情况对数组进行扩容，比如扩容两倍。

同样的，在扩容之后，如果删除了很多元素导致元素很少，但是数组容量很大的情况下，也需要对数组做减小容量的操作。



`(ps: 扩容后/缩小容量后的bucket长度最好也是质数，有利于元素转换后的index值在数组中均匀分布，减少元素连串聚集的问题)`



##### 8.7.2 如何进行扩容/减小容量

在 loadFactor > 0.75 时进行增大两倍容量的操作

在 loadFactor < 0.25 时进行减小两倍容量的操作